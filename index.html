<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="" />
    <meta name="author" content="Maxim Sokhatsky" />
    <link href="https://fonts.googleapis.com/css?family=Montserrat:900" rel="stylesheet">
    <title>AXIO/8.0</title>
    <link rel="stylesheet" href="https://n2o.dev/blank.css" />
</head>
<body>
<nav>
    <a style="background-color:#00C2E7;color:white;" href='https://groupoid.space/institute/index.htm'>Groupo—ód Infinity</a>
</nav>
<header>
    <h1 style="border:0;color:#01C2E7;margin-right:20px;">AXIO</h1> <h1 style="color:PaleVioletRed;">8.0</h1>
</header>
<aside>
    <article>
        <section>
             <h3>SYNOPSIS</h3>
            <div>Groupo—ód Infinity fibrational type systems for
                 mathematical representation, certification (theorem proving),
                 with extraction to verified interpreter and its runtime.<br><br></div>
            <div>2016&mdash;2024 &copy; <a href="https://5ht.co/license/">ISC</a>
            <br><br></div>
        </section>
        <section>
             <h3>NOTES</h3>
            <div>The main research product is an AXIO/1 formal runtime that is
                 able to run simple typed lambda programs on verifiable interpreter Joe.
                 But nobody can limit one developing their own higher languages with
                 extraction to that interpreter. In order to keep that process in one place
                 under cathedral type of open source software management proceess ‚Äî the AXIO/1 appears.<br><br>
                 AXIO/1 consists of runtime and its languages Joe, Alice, Bob for software constructions that are using Standard ML like syntax;
                 and higher languages and its extractors to runtime Alonzo, Henk, Per, Anders for theorem proving
                 that are using Lean like syntax.
            </div>
        </section>
    </article>
</aside>
<main>
    <section>
        <p></p>
    </section>
    <section>
        <hr>
    </section>
    <section>
        <p>Verified Lambda Interpreter and Concurrent Parallel Matrix Runtime.
           Joe, Bob, and Alice languages share the same Standard ML like BNF grammar.</p>
    </section>
    <section>
        <a name=Joe></a>
        <h3><a href="https://github.com/groupoid/joe">Joe</a></h3>
         <p><b style="sel">Joe</b> is a certified bytecode stack interpreter and Intel/ARM code compiler.</p>
         <P>[1] ‚Äî MinCaml<br>
            [2] ‚Äî CoqASM<br>
            [3] ‚Äî Verified LISP Interpreter<br>
            [4] ‚Äî Kind<br>
         </p>
        <figure><code>
fun a (0, n) = n + 1
  | a (m, 0) = a (m - 1, 1)
  | a (m, n) = a (m - 1, a (m, n - 1))
        </code></figure>
    </section>
    <section>
        <a name=Bob></a>
        <h3><a href="https://github.com/o83/n2o">Bob</a></h3>
         <p><b style="sel">Bob</b> is a parallel concurrent non-blocking
            zero-copy run-time with CAS cursors [4,5].</p>
         <P>[5] ‚Äî Kernel<br>
            [6] ‚Äî Pony<br>
            [7] ‚Äî Erlang<br></p>
        <figure><code>
fun proc =
let val p0 = pub(0,8)
    val s1 = sub(0,p0)
    val s2 = sub(0,p0)
 in send(p0,11);
    send(p0,12);
    [ receive(s1);
      receive(s2);
      receive(s1);
      receive(s2)
    ]
    end
        </code></figure>
    </section>
    <section>
        <a name=Alice></a>
        <h3><a href="https://tonpa.guru/stream/2023/2023-09-25%20Formal%20Tensor.htm">Alice</a></h3>
         <p><b style="sel">Alice</b> is a linear types calculus
            with partial fractions [6] for BLAS level 3 programming.</p>
         <P>[8] ‚Äî NumLin<br> </p>
   <figure><code>
fun simpleConvolution (i n: int) (x0: float) (write w: vector float)
  : vector float
  = begin
      if n = i then result.emit(write),
      a = [w0,w1,w2] = w.get(0,3),
      b = [x0,x1,x2] = [ x0 | write.get(i,2) ],
      write.set(i, Dotp(a,b)),
      simpleConvolution((i + 1),n,x1,write,w)
    end
     </code></figure>
    </section>
    <section>
        <hr>
    </section>
    <section>
        <p>Sound and Consistent Predicative Formal Languages.
           Alonzo, Henk, Per, Anders languages share the same Lean like BNF grammar.</p>
    </section>
    <section>
        <a name=Alonzo></a>
        <h3><a href="https://github.com/groupoid/alonzo">Alonzo</a></h3>
         <p><b style="sel">Alonzo</b> is an STLC-40 type system as example of core
         calculus discovered before fibrational Œ†Œ£ provers.</p>
         <p>
           STLC-40 ‚Äî Simple Theory of Types<br>
         </p>

         <figure><code>
def zero : (T ‚Üí T) ‚Üí T ‚Üí T := Œª (s: T ‚Üí T) (z: T), z
def succ : ((T ‚Üí T) ‚Üí T ‚Üí T) ‚Üí ((T ‚Üí T) ‚Üí T ‚Üí T)
 := Œª (w: (T ‚Üí T) ‚Üí T ‚Üí T) (y: T ‚Üí T) (x: T), y (w y x)
         </code></figure>

    </section>
    <section>
        <a name=Henk></a>
        <h3><a href="https://github.com/groupoid/henk">Henk</a></h3>
        <p><b style="sel">Henk</b> is a Pure Type System (PTS-91) in
             the style of Coquand/Huet Calculus of Inductive Constructions (CoC-88)
             with infinite numbere of universes. Henk also supports AUTOMATH syntax (AUT-68).</p>
        <p>
           AUT-68 ‚Äî AUTOMATH<br>
           CoC-88 ‚Äî Calculus of Constructions<br>
           PTS-91 ‚Äî Pure Type System (Œ†)<br>
        </p>

        <figure><code>
def N := Œ† (A : U), (A ‚Üí A) ‚Üí A ‚Üí A
def zero : N := Œª (A : U) (S : A ‚Üí A) (Z : A), Z
def succ : N -> N := Œª (n : N) (A : U) (S : A ‚Üí A) (Z : A), S (n A S Z)
def plus (m n : N) : N := Œª (A : U) (S : A ‚Üí A) (Z : A), m A S (n A S Z)
def mult (m n : N) : N := Œª (A : U) (S : A ‚Üí A) (Z : A), m A (n A S) Z
def pow (m n : N) : N := Œª (A : U) (S : A ‚Üí A) (Z : A), n (A ‚Üí A) (m A) S Z
        </code></figure>

    </section>
    <section>
        <a name=Per></a>
        <h3><a href="https://github.com/groupoid/per">Per</a></h3>
        <p><b style="sel">Per</b> is a Œ†Œ£ (MLTT-72) prover with Calculus of
           Inductive Constructions and idenitity types (MLTT-75). The natural
           extension of CoC to CIC was done by Frank Pfenning and Christine Paulin (IND-89).</p>
        <p>
           Mini-TT ‚Äî OCaml implementation<br>
           MLTT-72 ‚Äî Pi, Sigma<br>
           MLTT-75 ‚Äî Pi, Sigma, Id<br>
           MLTT-80 ‚Äî 0, 1, 2, W, Pi, Sigma, Id<br>
           PP-89 ‚Äî Inductively Defined Types<br>
           CIC-2015 ‚Äî Calculus of Inductive Constructiions<br>
        </p>
        <figure><code>
def empty      : U := inductive { }
def L¬π (A : U) : U := inductive { nil | cons (head: A) (tail: L¬π A) }
def S¬π         : U := inductive { base | loop : Equ S¬π base base }

def quot (A: U) (R : A -> A -> U) : U
 := inductive { quotient (a: A)
              | identification (a b: A) (r: R a b)
              : Equ (quot A R) (quotient a) (quotient b)
              }
        </code></figure>
    </section>
    <section>
        <a name=Anders></a>
        <h3><a href="https://github.com/groupoid/anders">Anders</a></h3>
        <p><b style="sel">Anders</b> is a Homotopy Type System (HTS-2013)
           with Strict Equality and Cubical Agda (CCHM-2016) primitives.</p>
        <p>
           HTS-2013 ‚Äî Homotopy Type System<br>
           BCH-2014 ‚Äî Cubical Sets<br>
           CCHM-2015 ‚Äî Cubical Type System<br>
           OP-2016 ‚Äî Topos Axioms<br>
           CHM-2017 ‚Äî Huber Equations<br>
           VMA-2017 ‚Äî Cubical Agda<br>
        </p>
        <figure><code>
def idfun  (A : U) : A ‚Üí A := Œª (a : A), a
def idfun‚Ä≤ (A : U) : A ‚Üí A := transp (&lt;i> A) 0
def idfun‚Ä≥ (A : U) : A ‚Üí A := Œª (a : A), hcomp A 0 (Œª (i : I), []) a
def isFiberBundle (B: U) (p: B ‚Üí U) (F: U): U
 := Œ£ (v: U) (w: surjective v B), (Œ† (x: v), PathP (&lt;_>U) (p (w.1 x)) F)
def ~~ (X : U) (a x‚Ä≤ : X) : U := Path (‚Ñë X) (Œπ X a) (Œπ X x‚Ä≤)
def ùîª (X : U) (a : X) : U := Œ£ (x‚Ä≤ : X), ~~ X a x‚Ä≤
def unitDisc (X : U) (x : ‚Ñë X) : U := Œ£ (x‚Ä≤ : X), Path (‚Ñë X) x (Œπ X x‚Ä≤)
def starDisc (X : U) (x : X) : ùîª X x := (x, idp (‚Ñë X) (Œπ X x))
def T‚àû (A : U) : U := Œ£ (a : A), ùîª A a
def inf-prox-ap (X Y : U) (f : X ‚Üí Y) (x x‚Ä≤ : X) (p : ~~ X x x‚Ä≤)
  : ~~ Y (f x) (f x‚Ä≤) := &lt;i> ‚Ñë-app X Y f (p @ i)
def d (X Y : U) (f : X ‚Üí Y) (x : X) (Œµ : ùîª X x) : ùîª Y (f x)
 := (f Œµ.1, inf-prox-ap X Y f x Œµ.1 Œµ.2)
def T‚àû-map (X Y : U) (f : X ‚Üí Y) (œÑ : T‚àû X) : T‚àû Y
 := (f œÑ.1, d X Y f œÑ.1 œÑ.2)
def is-homogeneous (A : U)
 := Œ£ (e : A) (t : A ‚Üí equiv A A),
    Œ† (x : A), Path A ((t x).1 e) x
         </code></figure>

    </section>
    <section>
        <a name=Urs></a>
        <h3><a href="https://github.com/groupoid/CCHM">Urs</a></h3>
        <p><b style="sel">Urs</b> is an equivariant superhomotopy type system
           with fermion and boson modalities built-in into type checker.
        </p>
        <p>
           R-HoTT ‚Äî Rezk Infinity Categories<br>
           G-HoTT ‚Äî Guarded Cubical<br>
           L-HoTT ‚Äî Linear HoTT<br>
           ES-HoTT ‚Äî Equivariant Super HoTT<br>
        </p>
    </section>
</main>
<footer> <br><br> Groupo—ód Infinity <span class=red> ‚ù§ </span> 2016‚Äî2024</footer>
</body>
</html>
